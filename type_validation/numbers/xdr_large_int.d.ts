import { LargeInt } from "@stellar/js-xdr";
import xdr from "../xdr.js";
type BigIntLike = {
    toBigInt(): bigint;
};
type XdrLargeIntValues = Array<BigIntLike | bigint | number | string> | BigIntLike | bigint | number | string;
export type ScIntType = 'duration' | 'i64' | 'i128' | 'i256' | 'timepoint' | 'u64' | 'u128' | 'u256';
/**
 * A wrapper class to represent large XDR-encodable integers.
 *
 * This operates at a lower level than {@link ScInt} by forcing you to specify
 * the type / width / size in bits of the integer you're targeting, regardless
 * of the input value(s) you provide.
 */
export declare class XdrLargeInt {
    int: LargeInt;
    type: string;
    /**
     * @param type - specifies a data type to use to represent the integer, one
     *    of: 'i64', 'u64', 'i128', 'u128', 'i256', 'u256', 'timepoint', and 'duration'
     *    (see {@link XdrLargeInt.isType})
     * @param values - a list of integer-like values interpreted in big-endian order
     */
    constructor(type: ScIntType, values: XdrLargeIntValues);
    /**
     * @throws {RangeError} if the value can't fit into a Number
     */
    toNumber(): number;
    toBigInt(): bigint;
    /**
     * The integer encoded with `ScValType = I64`
     * @throws {RangeError} if the value cannot fit in 64 bits
     */
    toI64(): xdr.ScVal;
    /** The integer encoded with `ScValType = U64` */
    toU64(): xdr.ScVal;
    /** The integer encoded with `ScValType = Timepoint` */
    toTimepoint(): xdr.ScVal;
    /** The integer encoded with `ScValType = Duration` */
    toDuration(): xdr.ScVal;
    /**
     * The integer encoded with `ScValType = I128`
     * @throws {RangeError} if the value cannot fit in 128 bits
     */
    toI128(): xdr.ScVal;
    /**
     * The integer encoded with `ScValType = U128`
     * @throws {RangeError} if the value cannot fit in 128 bits
     */
    toU128(): xdr.ScVal;
    /**
     * The integer encoded with `ScValType = I256`
     *
     * Note: No size check needed - I256 is the largest signed type.
     */
    toI256(): xdr.ScVal;
    /**
     * The integer encoded with `ScValType = U256`
     *
     * Note: No size check needed - U256 is the largest unsigned type.
     */
    toU256(): xdr.ScVal;
    /** The smallest interpretation of the stored value */
    toScVal(): xdr.ScVal;
    valueOf(): unknown;
    toString(): string;
    toJSON(): {
        value: string;
        type: string;
    };
    _sizeCheck(bits: number): void;
    static isType(type: string): boolean;
    /**
     * Convert the raw `ScValType` string (e.g. 'scvI128', generated by the XDR)
     * to a type description for {@link XdrLargeInt} construction (e.g. 'i128')
     *
     * @param scvType the `xdr.ScValType` as a string
     * @returns a suitable equivalent type to construct this object
     */
    static getType(scvType: string): string;
}
export {};
